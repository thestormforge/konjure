/*
Copyright 2021 GramLabs, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package konjure

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/thestormforge/konjure/internal/readers"
	"github.com/thestormforge/konjure/internal/spec"
	konjurev1beta2 "github.com/thestormforge/konjure/pkg/api/core/v1beta2"
	"sigs.k8s.io/kustomize/kyaml/kio"
	"sigs.k8s.io/kustomize/kyaml/yaml"
)

// Resource is a Konjure resource. This type may be used to collect Konjure
// resource specifications: either by URL-like string or by specifying the
// structured form of a resource. Only one of the pointers may be non-nil at
// a time.
type Resource struct {
	Resource   *konjurev1beta2.Resource   `json:"resource,omitempty" yaml:"resource,omitempty"`
	Helm       *konjurev1beta2.Helm       `json:"helm,omitempty" yaml:"helm,omitempty"`
	Jsonnet    *konjurev1beta2.Jsonnet    `json:"jsonnet,omitempty" yaml:"jsonnet,omitempty"`
	Kubernetes *konjurev1beta2.Kubernetes `json:"kubernetes,omitempty" yaml:"kubernetes,omitempty"`
	Kustomize  *konjurev1beta2.Kustomize  `json:"kustomize,omitempty" yaml:"kustomize,omitempty"`
	Secret     *konjurev1beta2.Secret     `json:"secret,omitempty" yaml:"secret,omitempty"`
	Git        *konjurev1beta2.Git        `json:"git,omitempty" yaml:"git,omitempty"`
	HTTP       *konjurev1beta2.HTTP       `json:"http,omitempty" yaml:"http,omitempty"`
	File       *konjurev1beta2.File       `json:"file,omitempty" yaml:"file,omitempty"`

	// Some specs (default reader, `data:` URLs, inline resources) resolve to a stream.
	raw kio.Reader `json:"-"` // NOTE: when this is non-nil there MUST be a value for `str`!

	// Original string representation this resource was parsed from.
	str string `json:"-"`
}

// NewResource returns a resource for parsing the supplied resource specifications. This
// is a convenience function for abstracting away gratuitous use of the word "resource".
func NewResource(arg ...string) Resource {
	r := Resource{Resource: &konjurev1beta2.Resource{Resources: arg}} // Turtles...
	if len(arg) == 1 {
		r.str = arg[0]
	}
	return r
}

// Read returns a KYAML resource nodes representing this Konjure resource.
func (r *Resource) Read() ([]*yaml.RNode, error) {
	if r.raw != nil {
		return r.raw.Read()
	}

	rv := reflect.Indirect(reflect.ValueOf(r))
	for i := 0; i < rv.NumField(); i++ {
		if f := rv.Field(i); f.Kind() != reflect.String && !f.IsNil() {
			n, err := konjurev1beta2.GetRNode(rv.Field(i).Interface())
			if err != nil {
				return nil, err
			}
			return []*yaml.RNode{n}, nil
		}
	}

	return nil, fmt.Errorf("resource is missing definition")
}

// UnmarshalJSON allows a Konjure resource to be represented by a plain URL-like
// string or a typed structure.
func (r *Resource) UnmarshalJSON(bytes []byte) error {
	if err := json.Unmarshal(bytes, &r.str); err == nil {
		rr, err := (&spec.Parser{}).Decode(r.str)
		if err != nil {
			return err
		}

		if raw, ok := rr.(kio.Reader); ok {
			r.raw = raw
			return nil
		}

		rv := reflect.Indirect(reflect.ValueOf(r))
		rrv := reflect.ValueOf(rr)
		for i := 0; i < rv.NumField(); i++ {
			if rv.Field(i).Type() == rrv.Type() {
				rv.Field(i).Set(rrv)
				return nil
			}
		}

		return fmt.Errorf("unknown resource type: %T", rr)
	}

	type rt *Resource
	return json.Unmarshal(bytes, rt(r))
}

// MarshalJSON produces JSON for this Konjure resource. If it was initially read
// from a string, the string representation is used, however changes made to the
// object will not be reflected.
func (r *Resource) MarshalJSON() ([]byte, error) {
	if r.str != "" {
		return json.Marshal(r.str)
	}

	rv := reflect.Indirect(reflect.ValueOf(r))
	for i := 0; i < rv.NumField(); i++ {
		if !rv.Field(i).IsNil() {
			str, err := (&spec.Formatter{}).Encode(rv.Field(i).Interface())
			if err != nil {
				break
			}
			return json.Marshal(str)
		}
	}

	type rt Resource
	return json.Marshal((*rt)(r))
}

// DeepCopyInto is meant to allow Resource to be used with code generated by
// Kubernetes controller-gen. It is not a true deep copy, it will only copy the
// destination of the non-nil pointers.
func (r *Resource) DeepCopyInto(rout *Resource) {
	rout.str = r.str

	rvin := reflect.Indirect(reflect.ValueOf(r))
	rvout := reflect.Indirect(reflect.ValueOf(rout))
	for i := 0; i < rvin.NumField(); i++ {
		if f := rvin.Field(i); f.Kind() != reflect.String && !f.IsNil() {
			rvout.Field(i).Set(reflect.New(f.Elem().Type()))
			rvout.Field(i).Elem().Set(f.Elem())
		}
	}
}

// Resources is a list of Konjure resources, it can be used as a KYAML Reader
// to obtain YAML representations of the Konjure resources.
type Resources []Resource

var _ kio.Reader = Resources{}

// Read returns the RNode representations of the Konjure resources.
func (rs Resources) Read() ([]*yaml.RNode, error) {
	result := make([]*yaml.RNode, 0, len(rs))
	for i := range rs {
		nodes, err := rs[i].Read()
		if err != nil {
			return nil, err
		}
		result = append(result, nodes...)
	}

	return result, nil
}

// NewReader returns a KYAML reader for an individual Konjure resource
// specification. If the object is not recognized, the resulting reader will
// silently generate nothing.
func NewReader(obj interface{}) kio.Reader {
	if r := readers.New(obj); r != nil {
		return r
	}

	// Use an empty RNode slice instead of returning nil
	return kio.ResourceNodeSlice{}
}
